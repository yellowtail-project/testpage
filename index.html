<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>iPad Safari - 録画 + 自動保存（動画/CSV）</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 16px;
        }

        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 10px 14px;
            font-size: 16px;
        }

        input {
            padding: 10px 12px;
            font-size: 16px;
        }

        label {
            font-size: 14px;
            color: #333;
        }

        video {
            width: 320px;
            max-width: 100%;
            background: #000;
            border-radius: 8px;
        }

        .hint {
            color: #555;
            font-size: 13px;
        }

        .status {
            white-space: pre-wrap;
            background: #f6f6f6;
            padding: 12px;
            border-radius: 8px;
            max-width: 760px;
        }

        /* カウントダウン（プログレス表示） */
        .progressWrap {
            width: 320px;
            max-width: 100%;
            height: 16px;
            border-radius: 999px;
            background: #e5e5e5;
            overflow: hidden;
        }

        .progressBar {
            height: 100%;
            width: 0%;
            background: #3b82f6;
            transition: width 100ms linear;
        }

        .progressText {
            font-size: 13px;
            color: #444;
            margin-top: 6px;
        }

        /* 録画中オーバーレイ */
        .overlay {
            position: fixed;
            inset: 0;
            background: #000;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .overlay img {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            background: #000;
        }

        /* 再ダウンロード */
        .links a {
            display: inline-block;
            margin-right: 12px;
        }

        .previewWrap {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* 中央寄せ */
            width: 320px;
            /* video幅に合わせる（既存と整合） */
            max-width: 100%;
        }

        .previewWrap video {
            width: 320px;
            max-width: 100%;
        }

        .flipCtl {
            margin-top: 8px;
            /* 真下に余白 */
            display: inline-flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            width: 100%;
            /* プレビュー幅いっぱいの中央 */
            user-select: none;
        }


        .mirror {
            transform: scaleX(-1);
        }
    </style>
</head>

<body>
    <h2>1033_録画 → 自動保存（動画.webm / 解析.csv）</h2>

    <p class="hint">
        ※HTTPSで配信してください。Safariのダウンロード保存は、端末設定や操作（保存先選択）により挙動が変わります。
    </p>

    <!-- ユーザーID行 -->
    <div class="row">
        <div>
            <label for="userId">ユーザーID</label><br />
            <input id="userId" placeholder="例：A001" />
        </div>
    </div>

    <!-- カウントダウン秒数行 -->
    <div class="row">
        <div>
            <label for="countdownSec">カウントダウン秒数（デフォルト3秒）</label><br />
            <input id="countdownSec" type="number" min="0" step="1" value="3" style="width: 160px;" />
        </div>
    </div>


    <div class="row" style="margin-top: 12px;">
        <button id="btnCam">カメラ起動（インカメ）</button>
        <button id="btnRec" disabled>撮影開始</button>
    </div>

    <div style="margin-top: 12px;">
        <div class="hint">カウントダウン（プログレス）</div>
        <div class="progressWrap">
            <div id="progressBar" class="progressBar"></div>
        </div>
        <div id="progressText" class="progressText">待機中</div>
    </div>

    <div class="row" style="margin-top: 12px;">
        <div class="previewWrap">
            <div class="hint">プレビュー（カメラ）</div>
            <video id="preview" playsinline autoplay muted></video>

            <label class="flipCtl">
                <input id="flipCam" type="checkbox" />
                カメラをフリップ（左右反転）
            </label>
        </div>



    </div>

    <div style="margin-top: 12px;">
        <div class="hint">再ダウンロードリンク</div>
        <div class="links">
            <a id="videoLink" href="#" download>動画を再ダウンロード</a>
            <a id="csvLink" href="#" download>CSVを再ダウンロード</a>
        </div>
    </div>

    <div>
        <div class="hint">録画Blob再生</div>
        <video id="playback" playsinline controls></video>
    </div>



    <div style="margin-top: 12px;">
        <div class="hint">ステータス</div>
        <div id="status" class="status">待機中</div>
    </div>

    <!-- 録画中に全画面表示する画像（URLを適宜差し替え） -->
    <div id="overlay" class="overlay">
        <img id="overlayImg" alt="recording overlay" />
    </div>

    <script type="module">
        import { FilesetResolver, FaceLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.21";

        // ===== 設定（ここだけ変えればOK） =====
        const PRODUCT_NAME = "PRODUCT"; // 事前指定の製品名（例: "kirei" などに変更）
        const RECORDING_OVERLAY_IMAGE_URL = "https://yellowtail-project.github.io/testpage/test_background3.png"; // 録画中に全画面表示する画像URL
        // ===================================

        const btnCam = document.getElementById("btnCam");
        const btnRec = document.getElementById("btnRec");
        const preview = document.getElementById("preview");
        const flipCam = document.getElementById("flipCam");

        // 初期状態（任意：インカメの見た目を「鏡」にしたいなら true に）
        flipCam.checked = true

        function applyPreviewFlip() {
            preview.classList.toggle("mirror", flipCam.checked);
        }

        flipCam.addEventListener("change", applyPreviewFlip);
        applyPreviewFlip();




        const playback = document.getElementById("playback");

        const userIdEl = document.getElementById("userId");
        const countdownSecEl = document.getElementById("countdownSec");

        const progressBar = document.getElementById("progressBar");
        const progressText = document.getElementById("progressText");

        const statusEl = document.getElementById("status");
        const videoLink = document.getElementById("videoLink");
        const csvLink = document.getElementById("csvLink");

        const overlay = document.getElementById("overlay");
        const overlayImg = document.getElementById("overlayImg");
        overlayImg.src = RECORDING_OVERLAY_IMAGE_URL;

        let stream = null;
        let recorder = null;
        let chunks = [];
        let faceLandmarker = null;

        let captureFps = 30;

        // 保存用（再ダウンロード用URL）
        let lastVideoBlobUrl = null;
        let lastCsvBlobUrl = null;

        // ===== 変更①：CSV用の保持形式を「横持ち」に変更（グローバル付近） =====
        // 解析結果（CSV用）
        // 1行 = 1タイムスタンプ、列 = 各blendshape
        let blendshapeNames = []; // ヘッダー（categoryName一覧）
        let frameRows = [];       // { t: "0.033", values: number[] | null } の配列


        function setStatus(msg) {
            statusEl.textContent = msg;
        }

        function sanitizeFilePart(s) {
            // ファイル名に使えない文字をざっくり除去
            return String(s || "").trim().replace(/[\\\/:*?"<>|\s]+/g, "_");
        }

        function makeBaseName() {
            const uid = sanitizeFilePart(userIdEl.value);
            if (!uid) return null;
            return `${uid}_${PRODUCT_NAME}`;
        }

        function makeFileNames() {
            const base = makeBaseName();
            if (!base) return null;
            return {
                video: `${base}.webm`,
                csv: `${base}.csv`,
            };
        }

        function revokeIfAny(url) {
            if (url) URL.revokeObjectURL(url);
        }

        function setDownloadLink(anchor, blob, filename) {
            const url = URL.createObjectURL(blob);
            anchor.href = url;
            anchor.download = filename;
            return url;
        }

        async function initMediapipe() {
            if (faceLandmarker) return faceLandmarker;

            const fileset = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.21/wasm"
            );

            faceLandmarker = await FaceLandmarker.createFromOptions(fileset, {
                baseOptions: {
                    modelAssetPath:
                        "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
                    delegate: "GPU",
                },
                runningMode: "VIDEO",
                outputFaceBlendshapes: true,
                numFaces: 1,
            });

            return faceLandmarker;
        }

        function sleep(ms) {
            return new Promise((r) => setTimeout(r, ms));
        }

        function once(el, name) {
            return new Promise((resolve, reject) => {
                const onOk = () => {
                    cleanup();
                    resolve();
                };
                const onErr = (e) => {
                    cleanup();
                    reject(e);
                };
                const cleanup = () => {
                    el.removeEventListener(name, onOk);
                    el.removeEventListener("error", onErr);
                };
                el.addEventListener(name, onOk, { once: true });
                el.addEventListener("error", onErr, { once: true });
            });
        }

        async function seekTo(timeSec) {
            playback.currentTime = timeSec;
            await once(playback, "seeked");
            await sleep(0);
            if (playback.readyState < 2) {
                await once(playback, "loadeddata");
            }
        }

        function showOverlay(on) {
            overlay.style.display = on ? "flex" : "none";
        }

        async function runCountdown(sec) {
            const total = Math.max(0, Number(sec) || 0);
            if (total === 0) {
                progressBar.style.width = "100%";
                progressText.textContent = "カウントダウンなし（0秒）";
                return;
            }

            const start = performance.now();
            const end = start + total * 1000;
            progressBar.style.width = "0%";
            progressText.textContent = `カウントダウン開始: ${total}s`;

            // できるだけ滑らかに更新
            while (true) {
                const now = performance.now();
                const p = Math.min(1, (now - start) / (total * 1000));
                progressBar.style.width = `${(p * 100).toFixed(1)}%`;
                const remain = Math.max(0, (end - now) / 1000);
                progressText.textContent = `開始まで: ${remain.toFixed(1)}s`;
                if (p >= 1) break;
                await sleep(50);
            }
            progressText.textContent = "開始";
        }

        function autoDownload(blob, filename) {
            // iOS Safariは「完全自動保存」が制限される場合があります。
            // ただしユーザー操作（撮影開始ボタン）からの一連の処理内で a.click() は通りやすいです。
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.style.display = "none";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            // revokeは少し遅らせる（DL開始前に消える事故を避ける）
            setTimeout(() => URL.revokeObjectURL(a.href), 60_000);
        }

        // ===== 変更②：rowsToCsv を「t + 各blendshape列」形式に差し替え =====
        function rowsToCsv(rowsWide, names) {
            const header = ["t_sec", ...names];

            const escape = (v) => {
                const s = String(v ?? "");
                return /[",\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
            };

            const lines = [header.map(escape).join(",")];

            for (const r of rowsWide) {
                // NO_FACE等でvaluesが無い場合は空欄で埋める
                const vals = Array.isArray(r.values) ? r.values : new Array(names.length).fill("");
                lines.push([r.t, ...vals].map(escape).join(","));
            }

            return lines.join("\n");
        }


        // ===== 変更③：analyzeVideoFramesBySeekingToCsv の中身（rowsを作る部分）を差し替え =====
        async function analyzeVideoFramesBySeekingToCsv() {
            const landmarker = await initMediapipe();
            playback.pause();

            if (!isFinite(playback.duration) || playback.duration <= 0) {
                throw new Error("動画durationが取得できませんでした。");
            }

            const fps = Math.max(1, Math.round(captureFps || 30));
            const step = 1 / fps;

            const duration = playback.duration;
            const totalFrames = Math.max(1, Math.floor(duration * fps));

            // ★ここが変更：初期化
            blendshapeNames = [];
            frameRows = [];

            for (let i = 0; i < totalFrames; i++) {
                const t = i * step;
                const tClamped = Math.min(Math.max(0, t), Math.max(0, duration - 0.0001));
                await seekTo(tClamped);

                const result = landmarker.detectForVideo(playback, t * 1000);
                const face = result.faceBlendshapes?.[0];

                if (!face) {
                    // 顔なし：ヘッダー確定後なら空欄行、未確定なら一旦空で入れる
                    frameRows.push({ t: tClamped.toFixed(3), values: null });
                } else {
                    // 初回にヘッダー（blendshape名）を確定
                    if (blendshapeNames.length === 0) {
                        blendshapeNames = face.categories.map((c) => c.categoryName);
                    }

                    // categoryName -> score の辞書を作って、ヘッダー順に並べる
                    const map = new Map(face.categories.map((c) => [c.categoryName, c.score]));
                    const values = blendshapeNames.map((name) => {
                        const v = map.get(name);
                        // 6桁固定（数値としてCSVに入る）
                        return (typeof v === "number") ? Number(v).toFixed(6) : "";
                    });

                    frameRows.push({ t: tClamped.toFixed(3), values });
                }

                if (i % 10 === 0) {
                    setStatus(
                        `解析中...\n` +
                        `fps=${fps}, duration=${duration.toFixed(3)}s\n` +
                        `frame ${i + 1}/${totalFrames}\n` +
                        `rows=${frameRows.length}\n` +
                        `cols=${blendshapeNames.length > 0 ? (1 + blendshapeNames.length) : "(ヘッダー未確定)"}`
                    );
                }
            }

            // ヘッダーが最後まで確定しなかった（ずっとNO_FACE）場合の保険
            if (blendshapeNames.length === 0) {
                blendshapeNames = ["NO_FACE"];
                // values=null の行を NO_FACE 列付き（空欄）にしてもOKだが、ここではそのまま
            }

            setStatus(
                `解析完了\n` +
                `fps=${fps}, duration=${duration.toFixed(3)}s\n` +
                `frames=${totalFrames}, rows=${frameRows.length}\n` +
                `cols=${1 + blendshapeNames.length}`
            );

            return { fps, duration, totalFrames };
        }


        btnCam.addEventListener("click", async () => {
            setStatus("カメラ起動中...");
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: "user",
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 30, max: 30 },
                    },
                    audio: false,
                });

                try {
                    const track = stream.getVideoTracks()[0];
                    const settings = track.getSettings?.() || {};
                    if (typeof settings.frameRate === "number" && settings.frameRate > 0) {
                        captureFps = settings.frameRate;
                    } else {
                        captureFps = 30;
                    }
                } catch {
                    captureFps = 30;
                }

                preview.srcObject = stream;
                applyPreviewFlip();
                await initMediapipe();

                btnRec.disabled = false;
                setStatus(`カメラ起動OK（推定fps=${Math.round(captureFps)}）`);
            } catch (e) {
                console.error(e);
                setStatus("カメラ起動に失敗: " + e.message);
            }
        });

        btnRec.addEventListener("click", async () => {
            // ユーザー操作起点でまとめて実行（自動DLが通りやすい）
            const names = makeFileNames();
            if (!names) {
                alert("ユーザーIDを入力してください");
                return;
            }

            const countdownSec = Math.max(0, Number(countdownSecEl.value) || 0);

            // 既存URLを破棄
            revokeIfAny(lastVideoBlobUrl);
            revokeIfAny(lastCsvBlobUrl);
            lastVideoBlobUrl = null;
            lastCsvBlobUrl = null;
            videoLink.href = "#";
            csvLink.href = "#";
            videoLink.download = "";
            csvLink.download = "";

            // カウントダウン
            btnRec.disabled = true;
            btnCam.disabled = true;
            try {
                await runCountdown(countdownSec);
            } catch (e) {
                console.error(e);
            }

            // 録画開始
            setStatus("録画開始...");
            chunks = [];

            try {
                recorder = new MediaRecorder(stream);
            } catch (e) {
                setStatus("MediaRecorderが使えない/初期化できない: " + e.message);
                btnRec.disabled = false;
                btnCam.disabled = false;
                return;
            }

            // 録画中は全画面画像を表示
            showOverlay(true);

            recorder.ondataavailable = (ev) => {
                if (ev.data && ev.data.size > 0) chunks.push(ev.data);
            };

            recorder.onstop = async () => {
                showOverlay(false);

                const blob = new Blob(chunks, { type: recorder.mimeType || "video/webm" });
                setStatus(
                    `録画完了\n` +
                    `mimeType=${recorder.mimeType || "(unknown)"}\n` +
                    `Blob size=${blob.size.toLocaleString()} bytes\n` +
                    `解析準備中...`
                );

                // Blobを再生用videoへ
                const url = URL.createObjectURL(blob);
                playback.src = url;
                playback.currentTime = 0;

                await new Promise((res) => {
                    if (playback.readyState >= 1) return res();
                    playback.onloadedmetadata = () => res();
                });

                // 解析（CSV生成）
                try {
                    await analyzeVideoFramesBySeekingToCsv();
                } catch (e) {
                    console.error(e);
                    setStatus("解析に失敗: " + e.message);
                    // 解析失敗でも動画保存リンクだけは作る
                }


                // ===== 変更④：CSV Blob生成部分（録画停止後）だけ差し替え =====
                // 旧：const csvText = rowsToCsv(rows);
                // 新：
                const csvText = rowsToCsv(frameRows, blendshapeNames);
                const csvBlob = new Blob([csvText], { type: "text/csv;charset=utf-8" });


                // 再ダウンロードリンクを作成（永続化はしない：メモリ上）
                lastVideoBlobUrl = setDownloadLink(videoLink, blob, names.video);
                lastCsvBlobUrl = setDownloadLink(csvLink, csvBlob, names.csv);

                // 自動保存（動画＋CSV）
                // ※ iOS Safariの制約で、環境によっては自動DLが「ダウンロード一覧」止まりになります
                try {
                    autoDownload(blob, names.video);
                } catch (e) {
                    console.warn("auto video download failed", e);
                }

                try {
                    autoDownload(csvBlob, names.csv);
                } catch (e) {
                    console.warn("auto csv download failed", e);
                }

                setStatus(
                    `完了\n` +
                    `動画: ${names.video}\n` +
                    `CSV: ${names.csv}\n` +
                    `（再ダウンロードリンクも作成済み）`
                );

                btnRec.disabled = false;
                btnCam.disabled = false;
            };

            recorder.start();

            // 録画時間は「カウントダウン」ではなく、固定で3秒のままにする想定（必要ならUI追加で変更可）
            const RECORD_SECONDS = 3;
            setTimeout(() => {
                if (recorder && recorder.state !== "inactive") recorder.stop();
            }, RECORD_SECONDS * 1000);
        });
    </script>

</body>

</html>
