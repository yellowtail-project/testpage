<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>iPad Safari - 録画 + 自動保存（動画）</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 16px;
        }

        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 10px 14px;
            font-size: 16px;
        }

        input {
            padding: 10px 12px;
            font-size: 16px;
        }

        label {
            font-size: 14px;
            color: #333;
        }

        video {
            width: 320px;
            max-width: 100%;
            background: #000;
            border-radius: 8px;
        }

        .hint {
            color: #555;
            font-size: 13px;
        }

        .status {
            white-space: pre-wrap;
            background: #f6f6f6;
            padding: 12px;
            border-radius: 8px;
            max-width: 760px;
        }

        /* カウントダウン（プログレス表示） */
        .progressWrap {
            width: 320px;
            max-width: 100%;
            height: 16px;
            border-radius: 999px;
            background: #e5e5e5;
            overflow: hidden;
        }

        .progressBar {
            height: 100%;
            width: 0%;
            background: #3b82f6;
            transition: width 100ms linear;
        }

        .progressText {
            font-size: 13px;
            color: #444;
            margin-top: 6px;
        }

        /* 録画中オーバーレイ */
        .overlay {
            position: fixed;
            inset: 0;
            background: #000;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .overlay img {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            background: #000;
        }

        /* 再ダウンロード */
        .links a {
            display: inline-block;
            margin-right: 12px;
        }

        .previewWrap {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 320px;
            max-width: 100%;
        }

        .previewWrap video {
            width: 320px;
            max-width: 100%;
        }

        .flipCtl {
            margin-top: 8px;
            display: inline-flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            width: 100%;
            user-select: none;
        }

        .mirror {
            transform: scaleX(-1);
        }
    </style>
</head>

<body>
    <h2>20251228_1809_録画 → 自動保存（動画）</h2>

    <p class="hint">
        ※HTTPSで配信してください。Safariのダウンロード保存は、端末設定や操作（保存先選択）により挙動が変わります。
    </p>

    <!-- ユーザーID行 -->
    <div class="row">
        <div>
            <label for="userId">ユーザーID</label><br />
            <input id="userId" placeholder="例：A001" />
        </div>
    </div>

    <!-- カウントダウン秒数行 -->
    <div class="row">
        <div>
            <label for="countdownSec">カウントダウン秒数（デフォルト3秒）</label><br />
            <input id="countdownSec" type="number" min="0" step="1" value="3" style="width: 160px;" />
        </div>
    </div>

    <div class="row" style="margin-top: 12px;">
        <button id="btnCam">カメラ起動（インカメ）</button>
        <button id="btnRec" disabled>撮影開始</button>
    </div>

    <div style="margin-top: 12px;">
        <div class="hint">カウントダウン（プログレス）</div>
        <div class="progressWrap">
            <div id="progressBar" class="progressBar"></div>
        </div>
        <div id="progressText" class="progressText">待機中</div>
    </div>

    <div class="row" style="margin-top: 12px;">
        <div class="previewWrap">
            <div class="hint">プレビュー（カメラ）</div>
            <video id="preview" playsinline autoplay muted></video>

            <label class="flipCtl">
                <input id="flipCam" type="checkbox" />
                カメラをフリップ（左右反転）
            </label>
        </div>
    </div>

    <div style="margin-top: 12px;">
        <div class="hint">再ダウンロードリンク</div>
        <div class="links">
            <a id="videoLink" href="#" download>動画を再ダウンロード</a>
        </div>
    </div>

    <div style="margin-top: 12px;">
        <div class="hint">録画Blob再生</div>
        <video id="playback" playsinline controls></video>
    </div>

    <div style="margin-top: 12px;">
        <div class="hint">ステータス</div>
        <div id="status" class="status">待機中</div>
    </div>

    <!-- 録画中に全画面表示する画像（URLを適宜差し替え） -->
    <div id="overlay" class="overlay">
        <img id="overlayImg" alt="recording overlay" />
    </div>

    <script type="module">
        // ===== 設定（ここだけ変えればOK） =====
        const PRODUCT_NAME = "PRODUCT"; // 事前指定の製品名（例: "kirei" などに変更）
        const RECORDING_OVERLAY_IMAGE_URL = "https://yellowtail-project.github.io/testpage/test_background3.png";
        const RECORD_SECONDS = 20; // 録画秒数
        // ===================================

        const btnCam = document.getElementById("btnCam");
        const btnRec = document.getElementById("btnRec");
        const preview = document.getElementById("preview");
        const playback = document.getElementById("playback");

        const flipCam = document.getElementById("flipCam");
        const userIdEl = document.getElementById("userId");
        const countdownSecEl = document.getElementById("countdownSec");

        const progressBar = document.getElementById("progressBar");
        const progressText = document.getElementById("progressText");

        const statusEl = document.getElementById("status");
        const videoLink = document.getElementById("videoLink");

        const overlay = document.getElementById("overlay");
        const overlayImg = document.getElementById("overlayImg");
        overlayImg.src = RECORDING_OVERLAY_IMAGE_URL;

        let stream = null;
        let recorder = null;
        let chunks = [];

        // 再ダウンロード用URL
        let lastVideoBlobUrl = null;

        // 初期状態（任意：インカメの見た目を「鏡」にしたいなら true に）
        flipCam.checked = true;

        function applyPreviewFlip() {
            preview.classList.toggle("mirror", flipCam.checked);
        }
        flipCam.addEventListener("change", applyPreviewFlip);
        applyPreviewFlip();

        function setStatus(msg) {
            statusEl.textContent = msg;
        }

        function sleep(ms) {
            return new Promise((r) => setTimeout(r, ms));
        }

        function showOverlay(on) {
            overlay.style.display = on ? "flex" : "none";
        }

        // ファイル名
        function sanitizeFilePart(s) {
            return String(s || "").trim().replace(/[\\\/:*?"<>|\s]+/g, "_");
        }
        function makeBaseName() {
            const uid = sanitizeFilePart(userIdEl.value);
            if (!uid) return null;
            return `${uid}_${PRODUCT_NAME}`;
        }

        // 端末ごとに録画mimeを良い感じに選ぶ（mp4優先→webm）
        function pickBestRecorderMimeType() {
            if (!("MediaRecorder" in window) || typeof MediaRecorder.isTypeSupported !== "function") {
                return "";
            }
            const mp4Candidates = [
                "video/mp4",
                "video/mp4;codecs=avc1,mp4a.40.2",
                "video/mp4;codecs=avc1.42E01E,mp4a.40.2",
                "video/mp4;codecs=h264,aac",
            ];
            for (const t of mp4Candidates) {
                try { if (MediaRecorder.isTypeSupported(t)) return t; } catch { }
            }

            const webmCandidates = [
                "video/webm",
                "video/webm;codecs=vp9,opus",
                "video/webm;codecs=vp8,opus",
                "video/webm;codecs=vp8",
            ];
            for (const t of webmCandidates) {
                try { if (MediaRecorder.isTypeSupported(t)) return t; } catch { }
            }
            return "";
        }

        function extFromMime(mime) {
            const m = (mime || "").toLowerCase();
            if (m.includes("video/mp4")) return "mp4";
            if (m.includes("video/webm")) return "webm";
            return "webm";
        }

        function revokeIfAny(url) {
            if (url) URL.revokeObjectURL(url);
        }

        function setDownloadLink(anchor, blob, filename) {
            const url = URL.createObjectURL(blob);
            anchor.href = url;
            anchor.download = filename;
            return url;
        }

        function autoDownload(blob, filename) {
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.style.display = "none";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(a.href), 60_000);
        }

        async function runCountdown(sec) {
            const total = Math.max(0, Number(sec) || 0);
            if (total === 0) {
                progressBar.style.width = "100%";
                progressText.textContent = "カウントダウンなし（0秒）";
                return;
            }

            const start = performance.now();
            const end = start + total * 1000;
            progressBar.style.width = "0%";
            progressText.textContent = `カウントダウン開始: ${total}s`;

            while (true) {
                const now = performance.now();
                const p = Math.min(1, (now - start) / (total * 1000));
                progressBar.style.width = `${(p * 100).toFixed(1)}%`;
                const remain = Math.max(0, (end - now) / 1000);
                progressText.textContent = `開始まで: ${remain.toFixed(1)}s`;
                if (p >= 1) break;
                await sleep(50);
            }
            progressText.textContent = "開始";
        }

        // 画面を消さない（対応ブラウザのみ）
        let wakeLock = null;
        async function requestWakeLock() {
            try {
                if (!("wakeLock" in navigator)) return false;
                wakeLock = await navigator.wakeLock.request("screen");
                wakeLock.addEventListener("release", () => { wakeLock = null; });
                return true;
            } catch {
                wakeLock = null;
                return false;
            }
        }
        async function releaseWakeLock() {
            try {
                if (wakeLock) {
                    await wakeLock.release();
                    wakeLock = null;
                }
            } catch {
                wakeLock = null;
            }
        }
        document.addEventListener("visibilitychange", async () => {
            if (document.visibilityState === "visible") {
                await requestWakeLock();
            } else {
                await releaseWakeLock();
            }
        });

        btnCam.addEventListener("click", async () => {
            setStatus("カメラ起動中...");
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: "user",
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 30, max: 30 },
                    },
                    audio: false,
                });

                preview.srcObject = stream;
                applyPreviewFlip();

                btnRec.disabled = false;
                setStatus("カメラ起動OK。次に「撮影開始」を押してください。");
            } catch (e) {
                console.error(e);
                setStatus("カメラ起動に失敗: " + e.message);
            }
        });

        btnRec.addEventListener("click", async () => {
            // 画面OFF防止（ユーザー操作起点で）
            await requestWakeLock();

            const base = makeBaseName();
            if (!base) {
                alert("ユーザーIDを入力してください");
                return;
            }

            const countdownSec = Math.max(0, Number(countdownSecEl.value) || 0);

            // 既存URL破棄
            revokeIfAny(lastVideoBlobUrl);
            lastVideoBlobUrl = null;
            videoLink.href = "#";
            videoLink.download = "";

            // カウントダウン
            btnRec.disabled = true;
            btnCam.disabled = true;
            try { await runCountdown(countdownSec); } catch { }

            // 録画開始
            setStatus("録画開始...");
            chunks = [];

            try {
                const preferredMime = pickBestRecorderMimeType();
                try {
                    recorder = preferredMime
                        ? new MediaRecorder(stream, { mimeType: preferredMime })
                        : new MediaRecorder(stream);
                } catch {
                    recorder = new MediaRecorder(stream);
                }
            } catch (e) {
                setStatus("MediaRecorderが使えない/初期化できない: " + e.message);
                btnRec.disabled = false;
                btnCam.disabled = false;
                await releaseWakeLock();
                return;
            }

            showOverlay(true);

            recorder.ondataavailable = (ev) => {
                if (ev.data && ev.data.size > 0) chunks.push(ev.data);
            };

            recorder.onstop = async () => {
                showOverlay(false);

                const blob = new Blob(chunks, { type: recorder.mimeType || "video/webm" });
                const actualMime = blob.type || recorder.mimeType || "";
                const videoExt = extFromMime(actualMime);
                const videoFileName = `${base}.${videoExt}`;

                setStatus(
                    `録画完了\n` +
                    `mimeType=${recorder.mimeType || "(unknown)"}\n` +
                    `Blob size=${blob.size.toLocaleString()} bytes\n` +
                    `保存処理中...`
                );

                // Blobを再生用videoへ
                const url = URL.createObjectURL(blob);
                playback.src = url;
                playback.currentTime = 0;

                // 再ダウンロードリンク
                lastVideoBlobUrl = setDownloadLink(videoLink, blob, videoFileName);

                // 自動保存（動画）
                try { autoDownload(blob, videoFileName); } catch (e) { console.warn("auto download failed", e); }

                setStatus(
                    `完了\n` +
                    `動画: ${videoFileName}\n` +
                    `mime: ${actualMime || "(unknown)"}\n` +
                    `（再ダウンロードリンクも作成済み）`
                );

                btnRec.disabled = false;
                btnCam.disabled = false;
                await releaseWakeLock();
            };

            recorder.start();

            setTimeout(() => {
                if (recorder && recorder.state !== "inactive") recorder.stop();
            }, RECORD_SECONDS * 1000);
        });
    </script>

</body>

</html>
