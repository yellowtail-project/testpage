<script>
    // 固定の録画中オーバーレイ画像URL（ユーザーは変更不可）
    const ALT_IMAGE_URL = "https://yellowtail-project.github.io/testpage/test_background3.png";

    // ======== ユーティリティ ========
    const el = (id) => document.getElementById(id);
    const preview = el('preview');
    const overlay = el('maskOverlay');
    const altPreviewFull = el('altPreviewFull');
    const flipToggle = el('flipX');
    const btnSetup = el('btnSetup');
    const btnStart = el('btnStart');
    const btnDiag = el('btnDiag');
    const phaseLabel = el('phaseLabel');
    const timeLeft = el('timeLeft');
    const progressBar = el('progressBar');
    const clipsTableBody = document.querySelector('#clipsTable tbody');
    const startHints = el('startHints');

    let stream = null, recorder = null, chunks = [], supportMime = null, loadedImage = false;

    // Flip
    function applyFlip() { preview.style.transform = flipToggle.checked ? 'scaleX(-1)' : 'none'; }
    flipToggle.addEventListener('change', applyFlip);

    // 画像の事前ロード（固定URL）
    async function loadImageFromUrl(url) {
        if (!url) { loadedImage = false; altPreviewFull.removeAttribute('src'); return false; }
        return new Promise((resolve) => {
            const test = new Image();
            test.onload = () => { altPreviewFull.src = url; loadedImage = true; resolve(true); };
            test.onerror = () => { loadedImage = false; altPreviewFull.removeAttribute('src'); resolve(false); };
            test.crossOrigin = 'anonymous';
            test.src = url;
        });
    }

    function unmetReasons() {
        const reasons = [];
        if (!el('participantId').value.trim()) reasons.push('被験者IDが未入力');
        if (!stream) reasons.push('カメラが未準備（「カメラを準備」を押してください）');
        if (!loadedImage) reasons.push('固定画像の読み込みに失敗（ALT_IMAGE_URL を確認）');
        return reasons;
    }

    function updateStartUI() {
        const reasons = unmetReasons();
        const ok = reasons.length === 0;
        btnStart.disabled = !ok;
        btnStart.title = ok ? '' : ('開始できない理由：\n- ' + reasons.join('\n- '));
        startHints.innerHTML = reasons.length
            ? ('<span class="bad">開始できない理由：</span> ' + reasons.map(r => `<span class="bad">${r}</span>`).join(' / '))
            : '<span class="good">開始可能です。② 撮影セッション開始 を押してください。</span>';
    }

    el('participantId').addEventListener('input', updateStartUI);

    function pickSupportedMime() {
        const cands = ['video/mp4', 'video/webm;codecs=vp8', 'video/webm'];
        for (const m of cands) {
            if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) return m;
        }
        return '';
    }

    function updateProgress(p) { progressBar.style.width = `${Math.max(0, Math.min(100, p * 100))}%`; }

    async function setupCamera() {
        try {
            const facing = el('cameraFacing').value;
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: { ideal: facing },
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: true
                });
            } catch (_) {
                stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            }
            preview.srcObject = stream;
            await preview.play().catch(() => { });
            supportMime = pickSupportedMime();
            phaseLabel.textContent = '準備OK';
        } catch (err) {
            phaseLabel.textContent = 'カメラ開始に失敗';
            alert('カメラ/マイク権限を許可してください。');
        } finally {
            applyFlip();
            updateStartUI();
        }
    }
    btnSetup.addEventListener('click', setupCamera);

    // Safe filename sanitizer
    function sanitizeForFilename(s) {
        return s
            .replace(/[\x00-\x1F\x7F]/g, '_')
            .replace(/[\\/:*?"<>|#%&{}$!'@+`=~;,]/g, '_')
            .replace(/\s+/g, '_');
    }

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    async function recordOne(productName) {
        const countdownSec = Math.max(0, parseInt(el('countdownSec').value || '10', 10));
        const recordSec = 20;

        // Count down
        phaseLabel.textContent = `カウントダウン (${productName})`;
        for (let t = countdownSec; t > 0; t--) {
            timeLeft.textContent = `${t}s`;
            updateProgress((countdownSec - t) / countdownSec);
            await sleep(1000);
        }
        timeLeft.textContent = '0s';
        updateProgress(1);

        // Record
        phaseLabel.textContent = '録画中';
        updateProgress(0);
        chunks = [];
        const mime = supportMime || undefined;
        try {
            recorder = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined);
        } catch (e) {
            alert('このブラウザは録画に対応していません');
            return;
        }
        let stopped = false;
        const startAt = Date.now();
        recorder.ondataavailable = (ev) => { if (ev.data && ev.data.size > 0) chunks.push(ev.data); };
        recorder.onstop = () => { stopped = true; };
        recorder.start();

        // Always fullscreen mask
        overlay.style.display = 'block';

        const targetMs = recordSec * 1000;
        const tickInt = setInterval(() => {
            const elapsed = Date.now() - startAt;
            const remain = Math.max(0, targetMs - elapsed);
            timeLeft.textContent = `${Math.ceil(remain / 1000)}s`;
            updateProgress(elapsed / targetMs);
        }, 200);
        await sleep(targetMs);
        try { recorder.stop(); } catch (_) { }
        for (let k = 0; k < 10 && !stopped; k++) await sleep(100);
        clearInterval(tickInt);

        // Hide overlay
        overlay.style.display = 'none';

        const blob = new Blob(chunks, { type: recorder.mimeType || mime || 'video/webm' });
        const durationMs = Date.now() - startAt;

        // Auto download (video)
        const id = el('participantId').value.trim() || 'Unknown';
        const seqNum = clipsTableBody.children.length + 1;
        const seq = String(seqNum).padStart(2, '0');
        const safeProd = sanitizeForFilename(productName);
        const ext = (recorder.mimeType || mime || 'video/webm').includes('mp4') ? 'mp4' : 'webm';
        const filename = `${id}_${seq}_${safeProd}.${ext}`;
        const tmpUrl = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = tmpUrl;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { URL.revokeObjectURL(tmpUrl); a.remove(); }, 1500);

        // ▼ 録画後 自動解析（Blendshape CSVのみ）
        if (window.processAnalysis) {
            const base = filename.replace(/\.(webm|mp4)$/i, "");
            await window.processAnalysis(blob, {
                filenameBase: base,
                maxAnalyticFps: 10  // Safari用に低めに設定
            });
        }
        // ▲ 自動解析ここまで

        // 完了メッセージ
        phaseLabel.textContent = '録画と解析が終了しました';
        timeLeft.textContent = '';
        updateProgress(0);
    }

    btnStart.addEventListener('click', async () => {
        // 固定画像の読み込みを最終確認
        const ok = await loadImageFromUrl(ALT_IMAGE_URL);
        if (!ok) { alert('固定画像URL (ALT_IMAGE_URL) を確認してください。'); return; }

        const id = el('participantId').value.trim();
        const productName = el('productName').value.trim() || 'Product';
        if (!id) { alert('被験者IDを入力してください'); return; }
        if (!stream) { alert('先に「カメラを準備」を押してください。'); return; }

        btnStart.disabled = true;
        el('participantId').disabled = true;
        el('productName').disabled = true;
        el('cameraFacing').disabled = true;
        btnSetup.disabled = true;

        await recordOne(productName);

        // 1本撮影後：再度やり直したい場合に備えて入力を戻す
        btnStart.disabled = false;
        el('participantId').disabled = false;
        el('productName').disabled = false;
        el('cameraFacing').disabled = false;
        btnSetup.disabled = false;
        updateStartUI();
    });

    async function updateStartUIInit() {
        await loadImageFromUrl(ALT_IMAGE_URL);
        updateStartUI();
        applyFlip();
    }
    document.addEventListener('DOMContentLoaded', updateStartUIInit);
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible' && preview.srcObject)
            preview.play().catch(() => { });
    });

    // Diagnose
    btnDiag.addEventListener('click', async () => {
        try {
            const secure = window.isSecureContext;
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                alert('enumerateDevices() が利用できません。');
                return;
            }
            const list = await navigator.mediaDevices.enumerateDevices();
            const summary = list.map(d => `${d.kind} : ${d.label || '(未許可)'} : ${d.deviceId ? d.deviceId.slice(0, 6) + '…' : ''}`).join('\n');
            alert('SecureContext: ' + secure + '\n' + 'デバイス一覧:\n' + summary + '\n\n※ (未許可) の場合、サイトのカメラ/マイク許可が必要です。');
        } catch (e) {
            alert('診断に失敗しました: ' + (e && e.message ? e.message : e));
        }
    });
</script>

<!-- ▼ 解析用依存: MediaPipe Tasks（FaceLandmarker）Safari最適化版 -->
<script type="module">
    import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.13/vision_bundle.mjs";

    let faceLandmarker = null;
    let isInitialized = false;

    // WASMローダ（Safari用エラーハンドリング強化）
    async function initializeFaceLandmarker() {
        if (isInitialized && faceLandmarker) return faceLandmarker;

        try {
            const fileset = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.13/wasm"
            );

            faceLandmarker = await FaceLandmarker.createFromOptions(fileset, {
                baseOptions: {
                    modelAssetPath:
                        "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
                    delegate: "GPU"  // Safari用にGPU指定
                },
                runningMode: "VIDEO",
                numFaces: 1,
                outputFaceBlendshapes: true
            });

            isInitialized = true;
            console.log("FaceLandmarker initialized successfully");
            return faceLandmarker;
        } catch (error) {
            console.error("FaceLandmarker initialization error:", error);
            throw error;
        }
    }

    function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = Object.assign(document.createElement("a"), { href: url, download: filename });
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 1500);
    }

    // Safari用: 動画シーク処理（タイムアウト・リトライ機能付き）
    async function seekVideoSafari(video, targetTime, maxRetries = 3) {
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        video.removeEventListener("seeked", onSeeked);
                        reject(new Error(`Seek timeout at ${targetTime}s`));
                    }, 2000);

                    const onSeeked = () => {
                        clearTimeout(timeout);
                        video.removeEventListener("seeked", onSeeked);
                        resolve();
                    };

                    video.addEventListener("seeked", onSeeked);
                    video.currentTime = targetTime;
                });

                // シーク成功後、フレームが準備できるまで待機
                await new Promise(r => setTimeout(r, 100));
                return true;
            } catch (error) {
                console.warn(`Seek attempt ${attempt + 1} failed:`, error);
                if (attempt === maxRetries - 1) {
                    console.error(`Failed to seek to ${targetTime}s after ${maxRetries} attempts`);
                    return false;
                }
                await new Promise(r => setTimeout(r, 200));
            }
        }
        return false;
    }

    // 公開API：録画Blob → Blendshape CSV を自動DL（Safari最適化）
    window.processAnalysis = async function processAnalysis(videoBlob, opts = {}) {
        const {
            filenameBase = "analysis",
            maxAnalyticFps = 10  // Safari用に10fpsに制限
        } = opts;

        const phaseLabel = document.getElementById("phaseLabel");
        if (phaseLabel) phaseLabel.textContent = "解析準備中...";

        // FaceLandmarkerの初期化
        try {
            await initializeFaceLandmarker();
        } catch (error) {
            alert("表情解析の初期化に失敗しました: " + error.message);
            if (phaseLabel) phaseLabel.textContent = "解析初期化失敗";
            return;
        }

        if (phaseLabel) phaseLabel.textContent = "動画読み込み中...";

        const v = document.createElement("video");
        v.src = URL.createObjectURL(videoBlob);
        v.muted = true;
        v.playsInline = true;
        v.preload = "auto";

        // メタデータの読み込みを待機
        await new Promise((resolve, reject) => {
            const timeout = setTimeout(() => reject(new Error("動画のメタデータ読み込みタイムアウト")), 10000);
            v.onloadedmetadata = () => {
                clearTimeout(timeout);
                resolve();
            };
            v.onerror = () => {
                clearTimeout(timeout);
                reject(new Error("動画の読み込みに失敗しました"));
            };
        });

        const duration = v.duration;
        const width = v.videoWidth || 640;
        const height = v.videoHeight || 360;

        console.log(`Video loaded: ${width}x${height}, duration: ${duration}s`);

        // Safari用: 解析フレームレートを固定（低めに設定）
        const analyticFps = Math.min(maxAnalyticFps, 10);
        const totalFrames = Math.max(1, Math.floor(duration * analyticFps));
        const times = Array.from({ length: totalFrames }, (_, i) =>
            Math.min(i / analyticFps, duration - 0.1)
        );

        console.log(`Will analyze ${totalFrames} frames at ${analyticFps} fps`);

        // Canvas準備（Safari用にシンプルな設定）
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");

        if (phaseLabel) phaseLabel.textContent = "解析中（表情推定）0%";

        let csvHeader = null;
        const csvRows = [];

        let successCount = 0;
        let failCount = 0;

        for (let i = 0; i < times.length; i++) {
            const t = times[i];

            // シーク処理
            const seekSuccess = await seekVideoSafari(v, t);
            if (!seekSuccess) {
                console.warn(`Skipping frame ${i} due to seek failure`);
                failCount++;
                continue;
            }

            // Canvas に描画
            try {
                ctx.drawImage(v, 0, 0, width, height);
            } catch (error) {
                console.error(`Failed to draw frame ${i}:`, error);
                failCount++;
                continue;
            }

            const nowMs = Math.round(t * 1000);

            // Blendshape解析
            try {
                const result = faceLandmarker.detectForVideo(v, nowMs);

                let row = [String(nowMs)];
                if (result?.faceBlendshapes?.length) {
                    const cats = result.faceBlendshapes[0].categories || [];
                    if (!csvHeader) {
                        csvHeader = ["timestamp_ms", ...cats.map(c => c.categoryName)];
                        csvRows.push(csvHeader);
                    }
                    const values = cats.map(c => c.score != null ? c.score.toFixed(6) : "0.000000");
                    row = [String(nowMs), ...values];
                } else {
                    if (!csvHeader) {
                        csvHeader = ["timestamp_ms"];
                        csvRows.push(csvHeader);
                    }
                }
                csvRows.push(row);
                successCount++;
            } catch (error) {
                console.error(`Error analyzing frame ${i}:`, error);
                // エラーが出ても空データで続行
                if (!csvHeader) {
                    csvHeader = ["timestamp_ms"];
                    csvRows.push(csvHeader);
                }
                csvRows.push([String(nowMs)]);
                failCount++;
            }

            // 進捗表示（5%刻み）
            if ((i % Math.max(1, Math.floor(totalFrames / 20))) === 0 && phaseLabel) {
                const pct = Math.round(((i + 1) / totalFrames) * 100);
                phaseLabel.textContent = `解析中… ${pct}%`;
            }
        }

        console.log(`Analysis complete: ${successCount} success, ${failCount} failures`);

        // CSV生成
        const csvText = csvRows.map(cols =>
            cols.map(v => (v?.includes(",") ? `"${v.replace(/"/g, '""')}"` : (v ?? ""))).join(",")
        ).join("\n");

        // CSV自動ダウンロード
        downloadBlob(
            new Blob([csvText], { type: "text/csv;charset=utf-8" }),
            `${filenameBase}_blendshape.csv`
        );

        // クリーンアップ
        URL.revokeObjectURL(v.src);
        v.remove();

        if (phaseLabel) phaseLabel.textContent = "録画と解析が終了しました";
        console.log("Analysis and download complete");
    };

    // 初期化を先に行う（ページロード時）
    document.addEventListener('DOMContentLoaded', () => {
        initializeFaceLandmarker().catch(err => {
            console.error("Failed to pre-initialize FaceLandmarker:", err);
        });
    });
</script>
<!-- ▲ 解析用依存ここまで ▲ -->
